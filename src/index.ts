import { app, BrowserWindow, ipcMain, IpcMainEvent, dialog } from "electron";
import fs from "fs";
import os from "os";

// Use require for node-pty to avoid module loading issues
// eslint-disable-next-line @typescript-eslint/no-var-requires
const pty: any = require("node-pty");

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

const shell = os.platform() === "win32" ? "powershell.exe" : "zsh";

let mainWindow: BrowserWindow = undefined;

// Store multiple terminal instances
const terminalProcesses = new Map<string, any>();

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // For AppBar
  ipcMain.on("minimize", () => {
    // eslint-disable-next-line no-unused-expressions
    mainWindow.isMinimized() ? mainWindow.restore() : mainWindow.minimize();
    // or alternatively: win.isVisible() ? win.hide() : win.show()
  });
  ipcMain.on("maximize", () => {
    // eslint-disable-next-line no-unused-expressions
    mainWindow.isMaximized() ? mainWindow.restore() : mainWindow.maximize();
  });

  ipcMain.on("close", () => {
    mainWindow.close();
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

/// Copied below

ipcMain.on("message", (event: IpcMainEvent, message: any) => {
  console.log(message);
  setTimeout(() => event.sender.send("message", "hi from electron"), 500);
});

// Terminal management
ipcMain.on("terminal.create", (_event: IpcMainEvent, terminalId: string) => {
  console.log("Creating terminal:", terminalId);

  const ptyProcess = pty.spawn(shell, [], {
    name: "xterm-color",
    cols: 80,
    rows: 30,
    cwd: process.env.HOME,
    env: process.env,
  });

  // Store the process
  terminalProcesses.set(terminalId, ptyProcess);

  // Handle data from this specific terminal
  ptyProcess.onData((data: string) => {
    mainWindow?.webContents?.send("terminal.incomingData", {
      terminalId,
      data,
    });
  });

  // Handle process exit
  ptyProcess.onExit(({ exitCode }: { exitCode: number }) => {
    console.log(`Terminal ${terminalId} exited with code:`, exitCode);
    // Check if terminal still exists in Map - if not, it was manually removed
    // and we don't need to notify the renderer (it already knows)
    const stillExists = terminalProcesses.has(terminalId);
    terminalProcesses.delete(terminalId);

    // Only notify renderer if this was an unexpected exit (not manually removed)
    if (stillExists) {
      mainWindow?.webContents?.send("terminal.exited", {
        terminalId,
        exitCode,
      });
    }
  });
});

ipcMain.on("terminal.remove", (_event: IpcMainEvent, terminalId: string) => {
  console.log("Removing terminal:", terminalId);

  const ptyProcess = terminalProcesses.get(terminalId);
  if (ptyProcess) {
    // Delete from Map BEFORE killing to prevent onExit from sending terminal.exited
    // The renderer already knows about this removal (it initiated it)
    terminalProcesses.delete(terminalId);
    ptyProcess.kill();
  }
});

ipcMain.on("terminal.keystroke", (_event, { terminalId, payload }) => {
  console.log({ "terminal.keystroke.payload": { terminalId, payload } });

  const ptyProcess = terminalProcesses.get(terminalId);
  if (ptyProcess) {
    ptyProcess.write(payload);
  } else {
    console.warn(`Terminal ${terminalId} not found`);
  }
});

// ^v : test me

ipcMain.on("getFile", async (event: IpcMainEvent, payload?: string) => {
  if (!payload) return;
  try {
    const bufferIdk = await fs.promises.readFile(`${payload}/package.json`);
    const textOutput = bufferIdk.toString();
    console.log({ textOutput });
    event.sender.send("getFile", textOutput);
  } catch (error) {
    console.error("Error reading file:", error);
    event.sender.send("getFile", "Error reading file");
  }
});

ipcMain.on(
  "goGetFolderOpenDialog",
  async (event: IpcMainEvent, payload?: string) => {
    let selectedFolderPath = "";
    console.log("goGetFolderOpenDialog -> MAIN", payload);
    if (payload) {
      // do like, pass the code a path, or if no path -popdialog to pick one
      selectedFolderPath = payload;
    } else {
      const result = await dialog.showOpenDialog({
        properties: ["openDirectory", "multiSelections"],
      });

      selectedFolderPath = result.filePaths[0];
    }

    try {
      const dirs = await fs.promises.readdir(selectedFolderPath);
      event.sender.send("getFolderResponse", {
        contents: dirs,
        selectedFolderPath,
      });
    } catch (error) {
      console.error("Error reading directory:", error);
      event.sender.send("getFolderResponse", {
        contents: [],
        selectedFolderPath: "",
      });
    }
  }
);

ipcMain.on(
  "goGetSpecificFolder",
  async (event: IpcMainEvent, selectedFolderPath?: string) => {
    if (!selectedFolderPath) {
      return false;
    }
    try {
      const dirs = await fs.promises.readdir(selectedFolderPath);
      event.sender.send("goGetSpecificFolder_Response", {
        contents: dirs,
        selectedFolderPath,
      });
    } catch (error) {
      console.error("Error reading directory:", error);
      event.sender.send("goGetSpecificFolder_Response", {
        contents: [],
        selectedFolderPath,
      });
    }
  }
);

ipcMain.on(
  "saveFile",
  async (event: IpcMainEvent, payload: { path: string; contents: string }) => {
    try {
      const { path, contents } = payload;
      await fs.promises.writeFile(path, contents.toString());
      event.sender.send("saveFileResponse", "success!");
    } catch (error) {
      console.error("Error saving file:", error);
      event.sender.send("saveFileResponse", "Error saving file");
    }
  }
);
